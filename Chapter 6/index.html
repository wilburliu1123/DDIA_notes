
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../Chapter%205/">
      
      
        <link rel="next" href="../Chapter%207/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.11">
    
    
      
        <title>Chapter 6 - DDIA Notes</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.fad675c6.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#partitioning-and-replication" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="DDIA Notes" class="md-header__button md-logo" aria-label="DDIA Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            DDIA Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 6
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
      </label>
    
  
</form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="DDIA Notes" class="md-nav__button md-logo" aria-label="DDIA Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    DDIA Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%201/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 1
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%2010/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 10
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%2011/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 11
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%2012/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 12
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%202/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 2
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%203/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 3
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%204/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 4
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%205/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 5
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Chapter 6
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Chapter 6
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#partitioning-and-replication" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning and Replication
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#partitioning-of-key-value-data" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning of Key-Value Data
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Partitioning of Key-Value Data">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how-do-we-decide-which-records-to-store-on-which-nodes" class="md-nav__link">
    <span class="md-ellipsis">
      how do we decide which records to store on which nodes?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partitioning-by-key-range" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning by Key Range
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partitioning-by-hash-of-key" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning by Hash of Key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#skewed-workloads-and-relieving-hot-spots" class="md-nav__link">
    <span class="md-ellipsis">
      Skewed Workloads and Relieving Hot Spots
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#partitioning-of-and-secondary-index" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning of and Secondary Index
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Partitioning of and Secondary Index">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#partitioning-secondary-indexes-by-document" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning Secondary Indexes by Document
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partitioning-secondary-index-by-term" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning Secondary Index by Term
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rebalancing-partitions" class="md-nav__link">
    <span class="md-ellipsis">
      Rebalancing Partitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Rebalancing Partitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#strategies-for-rebalancing" class="md-nav__link">
    <span class="md-ellipsis">
      Strategies for Rebalancing
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Strategies for Rebalancing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hash-mod-n" class="md-nav__link">
    <span class="md-ellipsis">
      hash mod N
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fixed-number-of-partitions" class="md-nav__link">
    <span class="md-ellipsis">
      Fixed number of partitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dynamic-partitioning" class="md-nav__link">
    <span class="md-ellipsis">
      Dynamic partitioning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partitioning-proportionally-to-nodes" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning proportionally to nodes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operations-automatic-or-manual-rebalancing" class="md-nav__link">
    <span class="md-ellipsis">
      Operations: Automatic or Manual Rebalancing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#request-routing" class="md-nav__link">
    <span class="md-ellipsis">
      Request Routing
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Request Routing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#parallel-query-execution" class="md-nav__link">
    <span class="md-ellipsis">
      Parallel Query Execution
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      Summary
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%207/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 7
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%208/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 8
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chapter%209/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter 9
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../FAQ/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Part%202/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part 2
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Part%203/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Part 3
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#partitioning-and-replication" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning and Replication
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#partitioning-of-key-value-data" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning of Key-Value Data
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Partitioning of Key-Value Data">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how-do-we-decide-which-records-to-store-on-which-nodes" class="md-nav__link">
    <span class="md-ellipsis">
      how do we decide which records to store on which nodes?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partitioning-by-key-range" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning by Key Range
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partitioning-by-hash-of-key" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning by Hash of Key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#skewed-workloads-and-relieving-hot-spots" class="md-nav__link">
    <span class="md-ellipsis">
      Skewed Workloads and Relieving Hot Spots
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#partitioning-of-and-secondary-index" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning of and Secondary Index
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Partitioning of and Secondary Index">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#partitioning-secondary-indexes-by-document" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning Secondary Indexes by Document
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partitioning-secondary-index-by-term" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning Secondary Index by Term
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rebalancing-partitions" class="md-nav__link">
    <span class="md-ellipsis">
      Rebalancing Partitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Rebalancing Partitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#strategies-for-rebalancing" class="md-nav__link">
    <span class="md-ellipsis">
      Strategies for Rebalancing
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Strategies for Rebalancing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hash-mod-n" class="md-nav__link">
    <span class="md-ellipsis">
      hash mod N
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fixed-number-of-partitions" class="md-nav__link">
    <span class="md-ellipsis">
      Fixed number of partitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dynamic-partitioning" class="md-nav__link">
    <span class="md-ellipsis">
      Dynamic partitioning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partitioning-proportionally-to-nodes" class="md-nav__link">
    <span class="md-ellipsis">
      Partitioning proportionally to nodes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operations-automatic-or-manual-rebalancing" class="md-nav__link">
    <span class="md-ellipsis">
      Operations: Automatic or Manual Rebalancing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#request-routing" class="md-nav__link">
    <span class="md-ellipsis">
      Request Routing
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Request Routing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#parallel-query-execution" class="md-nav__link">
    <span class="md-ellipsis">
      Parallel Query Execution
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      Summary
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>Chapter 6</h1>

<p>Chapter 5 discussed about replication without partitioning.(same dataset on each machine) This chapter will talk about break very large dataset into <em>partitions</em>, aka <em>sharding</em></p>
<p>Partition are defined where each record or document belongs to exactly one partition</p>
<p>As result, each partition is a small database itself</p>
<p>Scalability is the main reason for partitioning a dataset (different partition can be placed in a different machine/node for serving traffic), so query load is spread across different CPU and disk</p>
<p>Queries that can be done in a single partition will require only single machine to finish the query. So you can scale by adding more machine. 
Complex query where multiple partition can also benefit by executing the query in parallel (although it gets significantly harder)</p>
<p>We will look into different approach of partitioning and how indexing can effect your partition </p>
<h2 id="partitioning-and-replication">Partitioning and Replication<a class="headerlink" href="#partitioning-and-replication" title="Permanent link">&para;</a></h2>
<p>Partitioning usually go with replication together. (doesn't make sense if you don't replicate a partition because you will have single point of failure)</p>
<p>A node may store more than 1 partition. 
<img alt="partition_replication_combine_ex.png" src="../img/partition_replication_combine_ex.png" /></p>
<p>When leader-based replication scheme is used, everything from <a href="../Chapter%205/">Chapter 5</a> still applies here</p>
<h2 id="partitioning-of-key-value-data">Partitioning of Key-Value Data<a class="headerlink" href="#partitioning-of-key-value-data" title="Permanent link">&para;</a></h2>
<p>So we would like to split large dataset into partitions, </p>
<h4 id="how-do-we-decide-which-records-to-store-on-which-nodes">how do we decide which records to store on which nodes?<a class="headerlink" href="#how-do-we-decide-which-records-to-store-on-which-nodes" title="Permanent link">&para;</a></h4>
<p>Our goal is to query load evenly across nodes. So 10 nodes should handle 10 times as much data and 10 times as read and write throughput of a single node</p>
<p>If the partition is unfair, some partition will have more data or queries than others (known as <em>skewed</em>) This makes the partition less effective. In extreme, all load could end up on one partition, so 9 out of 10 nodes are idle. The partition with higher load is called <em>hot spot</em></p>
<p>One way to approach this is sort key by alphabetical order. Like encyclopedia. </p>
<h3 id="partitioning-by-key-range">Partitioning by Key Range<a class="headerlink" href="#partitioning-by-key-range" title="Permanent link">&para;</a></h3>
<p><img alt="sort_by_key_range.png" src="../img/sort_by_key_range.png" /></p>
<blockquote>
<p>If you also know which partition is assigned to which node, then you can make your request directly to the appropriate node (or, in the case of the encyclopedia, pick the correct book off the shelf).</p>
</blockquote>
<p>Simply have each volume begin with 2 letter will not work since data is distributed unevenly in this case.</p>
<blockquote>
<p>volume 1 contains words starting with A and B, but volume 12 contains words starting with T, U, V, X, Y, and Z.</p>
</blockquote>
<p>The partition boundaries need to adapt to the data.
Within each partition, we can keep key in sorted order (LSM tree or BTree all has this property)</p>
<p>key range partition makes <em>range scan</em> very easy. (like a network of sensors) However, downside of key range partitioning is that certain access patterns can lead to hot spots. </p>
<p>For example, all writes from same day goes to same partition due to the nature of timestamp. To avoid this problem, you could add prefix with the sensor name for each timestamp. Now when fetch for a range of value on a certain day, you can send to different partition (sensor name) with a date query </p>
<h3 id="partitioning-by-hash-of-key">Partitioning by Hash of Key<a class="headerlink" href="#partitioning-by-hash-of-key" title="Permanent link">&para;</a></h3>
<p>Many distributed DB use hash function to calculate partition of a given key
For example, Cassandra and MongoDB use MD5. Once you have hash function picked, you can assign each partition a range of hashes (compare to range of keys) 
<img alt="partition_by_hash.png" src="../img/partition_by_hash.png" />
However, partition by hash we lose the property of efficient range queries. (we lost the sorted order) In MongoDB, when hash-based sharding is turned on, range query has to be sent to all partitions. </p>
<p>Cassandra used <em>compound primary key</em> to avoid some of the issue where first part of the key is hashed to determine the partition and rest are sorted (for example, <code>(user_id, update_timestamp)</code>)</p>
<h3 id="skewed-workloads-and-relieving-hot-spots">Skewed Workloads and Relieving Hot Spots<a class="headerlink" href="#skewed-workloads-and-relieving-hot-spots" title="Permanent link">&para;</a></h3>
<p>Hashing a key cannot avoid issue where all reads and writes are for same key. (Celebrity on twitter or other social media sites)
example: <a href="https://mashable.com/archive/justin-bieber-twitter">3% of Twitter's server are  dedicated to Justin Bieber</a></p>
<blockquote>
<p>(where the key is perhaps the user ID of the celebrity, or the ID of the action that people are commenting on). Hashing the key doesn’t help, as the hash of two identical IDs is still the same.</p>
</blockquote>
<p>Most data systems cannot auto compensate for this skewed workload. Application has to deal with this individually. For example, add a random number to the beginning or end of the key. (Just two-digit random number would split the writes to the key evenly across 100 different keys, allow those keys to be distributed to different partitions) </p>
<p>This works but read have to do additional work, as they have to read all 100 partitions and combine it. So additional bookkeeping is required (which key are splited etc)</p>
<h2 id="partitioning-of-and-secondary-index">Partitioning of and Secondary Index<a class="headerlink" href="#partitioning-of-and-secondary-index" title="Permanent link">&para;</a></h2>
<p>When determine which partition to go for a given primary key, previous example works well. But things get complicated when secondary index are involved because secondary index doesn't identify the record uniquely (find all actions by user 123, all articles containing word <code>hogwash</code>, all cars color is <code>red</code>, etc)</p>
<p>There are 2 main approaches to partitioning a database with secondary indexes</p>
<ul>
<li>Document-based partitioning</li>
<li>Term-based partitioning</li>
</ul>
<h3 id="partitioning-secondary-indexes-by-document">Partitioning Secondary Indexes by Document<a class="headerlink" href="#partitioning-secondary-indexes-by-document" title="Permanent link">&para;</a></h3>
<p>Imagine operating a website for selling used cars. Each listing has unique ID (document ID. In order to search for car by <code>color</code> and <code>make</code>, you added secondary index. So partition is done by document ID
<img alt="partition_by_document_example.png" src="../img/partition_by_document_example.png" /></p>
<p>Reading from document-partitioned index requires <em>scatter/gather</em> which means read query needs to send to <em>all</em> partition since you don't know if this partition contains this secondary index or not and <em>combine</em> the results you get back</p>
<p>scatter/gather has long tail latency but widely used. </p>
<blockquote>
<p>MongoDB, Riak [15], Cassandra [16], Elasticsearch [17], SolrCloud [18], and VoltDB [19] all use document-partitioned secondary indexes.</p>
</blockquote>
<h3 id="partitioning-secondary-index-by-term">Partitioning Secondary Index by Term<a class="headerlink" href="#partitioning-secondary-index-by-term" title="Permanent link">&para;</a></h3>
<p>Rather each partition has its own secondary index (<em>local index</em>), we can construct a <em>global index</em> that covers data in all partitions </p>
<p>You can't just store global index in a single node so global index are also partitioned. </p>
<blockquote>
<p>red cars from all partitions appear under color:red in the index, but the index is partitioned so that colors starting with the letters a to r appear in partition 0 and colors starting with s to z appear in partition 1. The index on the make of car is partitioned similarly (with the partition boundary being between f and h).</p>
</blockquote>
<p><img alt="partition_by_term.png" src="../img/partition_by_term.png" /></p>
<p>This is called <em>term-partitioned</em> because the term we're looking for determines the partition of the index. term here would be <code>color:red</code> (term comes from full-text indexes)</p>
<p>exmaple<code>shakespear:[1,2,3,6,8]</code>
As before, we could partition by key(term itself) or hash 
<em>global index</em> has better read efficiency compare to <em>local index</em> since it doesn't need scatter/gather but lower write efficiency. Because write to a single document may now effect multiple partitions </p>
<blockquote>
<p>In practice, updates to global secondary indexes are often asynchronous (that is, if you read the index shortly after a write, the change you just made may not yet be reflected in the index). For example, Amazon DynamoDB states that its global secon‐ dary indexes are updated within a fraction of a second in normal circumstances, but may experience longer propagation delays in cases of faults in the infrastructure [20].</p>
</blockquote>
<h2 id="rebalancing-partitions">Rebalancing Partitions<a class="headerlink" href="#rebalancing-partitions" title="Permanent link">&para;</a></h2>
<p>Things changes over time in DB, 
- Query throughput increase, more CPU
- Dataset size increase, need to add more RAM and disk 
- Swap machines
All these changes might cause move data from one node to another
This process of moving data from one node to another is called <em>rebalancing</em>
Rebalancing is expected to meet some minimum requirements:
- After rebalance, load should be shared evenly for nodes in the cluster
- While rebalancing, database should still serve traffic
- Only data that is necessary to move (reduce unnecessary copy thus reduce disk and network load)</p>
<h3 id="strategies-for-rebalancing">Strategies for Rebalancing<a class="headerlink" href="#strategies-for-rebalancing" title="Permanent link">&para;</a></h3>
<h4 id="hash-mod-n">hash mod N<a class="headerlink" href="#hash-mod-n" title="Permanent link">&para;</a></h4>
<p>First, not to hash mod by N, why?</p>
<blockquote>
<p>The problem with the mod N approach is that if the number of nodes N changes, most of the keys will need to be moved from one node to another.</p>
<p>For example, say hash(key) = 123456. If you initially have 10 nodes, that key starts out on node 6 (because 123456 mod 10 = 6). When you grow to 11 nodes, the key needs to move to node 3 (123456 mod 11 = 3), and when you grow to 12 nodes, it needs to move to node 0 (123456 mod 12 = 0). Such frequent moves make rebalancing excessively expensive.</p>
</blockquote>
<p>We need an approach that doesn’t move data around more than necessary.</p>
<h4 id="fixed-number-of-partitions">Fixed number of partitions<a class="headerlink" href="#fixed-number-of-partitions" title="Permanent link">&para;</a></h4>
<p>Basically new node will steal some partition from current nodes and reverse if a node fails
<img alt="fiexed_number_of_partitions.png" src="../img/fiexed_number_of_partitions.png" /></p>
<h4 id="dynamic-partitioning">Dynamic partitioning<a class="headerlink" href="#dynamic-partitioning" title="Permanent link">&para;</a></h4>
<p>A fixed number of partition can easily got boundaries wrong and end up with all of the data in one partition. Reconfiguring the partition boundaries manually is very tedious</p>
<p>Dynamic partitioning is similar to BTrees split and merge:</p>
<blockquote>
<p>When a partition grows to exceed a configured size (on HBase, the default is 10 GB), it is split into two partitions so that approximately half of the data ends up on each side of the split</p>
<p>Dynamic partitioning is not only suitable for key range–partitioned data, but can equally well be used with hash-partitioned data. MongoDB since version 2.4 supports both key-range and hash partitioning, and it splits partitions dynamically in either case.</p>
</blockquote>
<p>Advantage:
Adapt to dataset size when increased, i.e. when total data volume increase, number of partition increase 
<img alt="dynamic_partition.png" src="../img/dynamic_partition.png" /></p>
<h4 id="partitioning-proportionally-to-nodes">Partitioning proportionally to nodes<a class="headerlink" href="#partitioning-proportionally-to-nodes" title="Permanent link">&para;</a></h4>
<p>Compare with dynamic partitioning where partitions increase when dataset size increase, decrease when dataset size decrease, fixed number of partition the size of each partition is proportional to the size of dataset.
The number of partition is <em>independent of the number of nodes</em> in both case.</p>
<p>A third option is to make the <em>number of partitions proportional to the number of nodes</em>
in other words, have fixed number of partition per node. </p>
<p>so each partition grows when their dataset size grow, but when new node join the cluster it will randomly choose partition to split and take ownership from half of those partition. 
more like consistent hashing shown below
<img alt="consistent_hashing_ex.png" src="../img/consistent_hashing_ex.png" />
https://tom-e-white.com/2007/11/consistent-hashing.html</p>
<h3 id="operations-automatic-or-manual-rebalancing">Operations: Automatic or Manual Rebalancing<a class="headerlink" href="#operations-automatic-or-manual-rebalancing" title="Permanent link">&para;</a></h3>
<p>So is automatic partition rebalancing better or manual rebalancing is better? </p>
<blockquote>
<p>Fully automated rebalancing can be convenient, because there is less operational work to do for normal maintenance. However, it can be unpredictable. Rebalancing is an expensive operation, because it requires rerouting requests and moving a large amount of data from one node to another. If it is not done carefully, this process can overload the network or the nodes and harm the performance of other requests while the rebalancing is in progress.</p>
</blockquote>
<p>Because of rerouting, it can hurt systems performance </p>
<blockquote>
<p>For that reason, it can be a good thing to have a human in the loop for rebalancing. It’s slower than a fully automatic process, but it can help prevent operational surprises.</p>
</blockquote>
<h2 id="request-routing">Request Routing<a class="headerlink" href="#request-routing" title="Permanent link">&para;</a></h2>
<p>Now we know how to partition our data onto multiple machines, but how do we route our client to correct partition when request comes in? </p>
<p>As partition are rebalanced, assignment of partition to nodes changes. So when client ask "I want to read or write to key <code>foo</code>", which IP address and port number we give to this client to connect to? </p>
<p>This is an instance of general problem called <em>service discovery</em>, which isn't just limit to DB but other type of server as well (load balancer). </p>
<blockquote>
<p>Many companies have written their own in- house service discovery tools, and many of these have been released as open source [30].</p>
</blockquote>
<p>There are few different approaches:
1. Allow clients to contact any node. (round-robin load balancer) if node contains the key then it takes the request, otherwise forward to the appropriate node
2. Send all request to routing tier first, then forward to correct node
3. Client know which node contains which partition and directly connect to the node upon request</p>
<p><img alt="3_diff_way_of_routing.png" src="../img/3_diff_way_of_routing.png" />
But how does it (node, routing tier, or client) know when configuration changes? 
Because it needs all node agree which partition resides on which node, so this is another consensus problem</p>
<p>Many distributed data systems rely on a separate coordination service such as ZooKeeper. ZooKeeper will be the source of truth for mapping of partitions to nodes.</p>
<p>Client or routing tier can subscribe to this information in ZooKeeper. Whenever there is a partition changes ownership, ZooKeeper notifies routing tier to updates its routing info
<img alt="zookeeper.png" src="../img/zookeeper.png" /></p>
<blockquote>
<p>For example, LinkedIn’s Espresso uses Helix [31] for cluster management (which in turn relies on ZooKeeper), implementing a routing tier as shown in Figure 6-8. HBase, SolrCloud, and Kafka also use ZooKeeper to track partition assignment. MongoDB has a similar architecture, but it relies on its own config server implementation and mongos daemons as the routing tier.</p>
</blockquote>
<p><a href="https://github.com/etcd-io/etcd">etcd</a> is another open source that does similar things (mostly used in k8s/docker world)</p>
<h3 id="parallel-query-execution">Parallel Query Execution<a class="headerlink" href="#parallel-query-execution" title="Permanent link">&para;</a></h3>
<p>For simple queries such as read or write single key, scatter/gather works pretty well. But in OLAP world, <em>massively parallel processing</em>(MPP) relational database often have queries contains several join, filtering, grouping, and aggregation operations. MPP query optimizer breaks this complex query into a number of execution stages and partitions, which can be executed in parallel on different nodes (<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2013/11/db-mr-survey-final.pdf">reference 33 is about MapReduce</a>, Spark etc)</p>
<blockquote>
<p>Fast parallel execution of data warehouse queries is a specialized topic, and given the business importance of analytics, it receives a lot of commercial interest. We will discuss some techniques for parallel query execution in Chapter 10. </p>
</blockquote>
<p>Snowflake went IPO </p>
<h2 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link">&para;</a></h2>
<p>We explored different ways of partitioning in this chapter. The goal of partitioning is to spread data evenly across different machine for scale.</p>
<p>This requires to choose partition schemes and rebalance partition when nodes join/leaves the cluster</p>
<p>2 main approach was discussed
- <em>Key range partitioning</em> (key are sorted like encyclopedia)
- <em>Hash partitioning</em> (hash function is applied to each key, each partition own a range of hashes)</p>
<p>Hybrid approaches are possible (compound key) </p>
<p>We discussed when partition involved with secondary indexes where it also need to be partitioned </p>
<p>2 methods are used:
- <em>Document partitioned indexes</em> (local index)
- <em>Term partitioned indexes</em> (global index) </p>
<p>Last but not least, routing queries to correct partition is discussed. </p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.6c14ae12.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
      
    
  </body>
</html>